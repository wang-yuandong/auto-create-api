var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/rollup.js
var rollup_exports = {};
__export(rollup_exports, {
  default: () => rollup_default
});
module.exports = __toCommonJS(rollup_exports);
var import_chokidar = __toESM(require("chokidar"), 1);

// src/create.js
var import_fs = __toESM(require("fs"), 1);
var import_ejs = __toESM(require("ejs"), 1);
var import_path = __toESM(require("path"), 1);
var import_url = require("url");
var import_meta = {};
var dirname = null;
try {
  dirname = __dirname;
} catch (e) {
  dirname = import_path.default.dirname((0, import_url.fileURLToPath)(import_meta.url));
}
var fileHeader = `/* eslint-disable */
/* prettier-ignore */
// @ts-nocheck
// Auto generated By auto-create-api,Do not modify this file directly.

import { request } from '../request'

`;
var createApiBaseInfo = (urlStr) => {
  const infos = urlStr.split("|");
  if (infos.length === 1) {
    return {};
  }
  const method = infos[0].toLowerCase();
  const arr = infos[1].split("/").filter(Boolean);
  const nameArr = arr.map((item, index) => {
    let handleStr = item;
    if (/^\{.*\}$/g.test(handleStr)) {
      handleStr = item.replace(/\{(\w+)\}/, (_, match) => "By" + match.charAt(0).toUpperCase() + match.slice(1));
    }
    handleStr = handleStr.charAt(0).toUpperCase() + handleStr.slice(1);
    handleStr = handleStr.replace(/[-_]+([a-z])/g, (_, match) => match.toUpperCase());
    return handleStr;
  });
  const urlArr = arr.map((item) => {
    return item.replace(/\{(\w+)\}/, "${params.$1}");
  });
  return {
    apiName: `${method}${nameArr.join("")}`,
    url: `/${urlArr.join("/")}`,
    method
  };
};
var convertApiPathToObject = (apiPathsJSON) => {
  const obj = {};
  Object.entries(apiPathsJSON).forEach(([key, value]) => {
    const subPathArr = key.split("/");
    const optionsArr = value.split("|");
    const { apiName, url, method } = createApiBaseInfo(key);
    if (!apiName || !url || !method) {
      return;
    }
    const apiOption = {
      apiName,
      url,
      method,
      requestType: optionsArr[0] || "String",
      responseType: optionsArr[1] || "JSON",
      isAuth: optionsArr[2] === "1"
    };
    const dirName = subPathArr[1];
    const fileName = subPathArr[2] || dirName;
    if (!obj[dirName]) {
      obj[dirName] = {};
      obj[dirName][fileName] = [apiOption];
    } else {
      if (obj[dirName][fileName]) {
        if (!obj[dirName][fileName].find((item) => item.apiName === apiOption.apiName)) {
          obj[dirName][fileName].push(apiOption);
        }
      } else {
        obj[dirName][fileName] = [apiOption];
      }
    }
  });
  return obj;
};
var createApiFile = (dirPath, fileExt, apiPathObj, templatePath) => {
  const oldDirs = import_fs.default.readdirSync(dirPath, { withFileTypes: true }).filter((item) => item.isDirectory());
  const oldFiles = oldDirs.map((item) => import_fs.default.readdirSync(import_path.default.join(item.path, item.name), { withFileTypes: true })).flat();
  oldFiles.forEach((item) => {
    if (item.isDirectory()) {
      import_fs.default.rmSync(import_path.default.join(item.path, item.name), { recursive: true });
    }
    item["fullPath"] = import_path.default.join(item.path, item.name);
    item["diffStatus"] = null;
  });
  const oldDirNames = oldDirs.map((item) => item.name);
  const newDirNames = Object.keys(apiPathObj);
  const filterNewDirNames = newDirNames.filter((item) => !oldDirNames.includes(item));
  const filterOldDirNames = oldDirNames.filter((item) => !newDirNames.includes(item));
  for (const item of filterOldDirNames) {
    const currentPath = import_path.default.join(dirPath, item);
    import_fs.default.rmSync(currentPath, { recursive: true });
  }
  for (const item of filterNewDirNames) {
    const currentPath = import_path.default.join(dirPath, item);
    import_fs.default.mkdirSync(currentPath);
  }
  const template = import_fs.default.readFileSync(import_path.default.join(dirname, "../templates", templatePath), "utf-8");
  Object.entries(apiPathObj).forEach(([key, value]) => {
    const folderPath = import_path.default.join(dirPath, key);
    Object.entries(value).forEach(([subKey, subValue]) => {
      const fileName = `${subKey}.api${fileExt}`;
      const filePath = import_path.default.join(folderPath, fileName);
      if (import_fs.default.existsSync(filePath)) {
        const oldContent = import_fs.default.readFileSync(filePath, "utf8");
        let content = fileHeader;
        for (let i = 0; i < subValue.length; i++) {
          content += import_ejs.default.render(template, subValue[i]);
        }
        if (oldContent !== content) {
          import_fs.default.writeFileSync(filePath, content);
        }
      } else {
        let content = fileHeader;
        for (let i = 0; i < subValue.length; i++) {
          content += import_ejs.default.render(template, subValue[i]);
        }
        import_fs.default.writeFileSync(filePath, content);
      }
      oldFiles.forEach((item) => {
        if (item.fullPath === filePath) {
          item.diffStatus = "done";
        }
      });
    });
  });
  oldFiles.forEach((item) => {
    if (!item.diffStatus && import_fs.default.existsSync(item.fullPath)) {
      import_fs.default.unlinkSync(item.fullPath);
    }
  });
};
var create = async (options) => {
  if (options.log) {
    console.time("auto-create-api");
  }
  const fileExt = options.ts ? ".ts" : ".js";
  const templatePath = options.ts ? "./template.ts.ejs" : "./template.ejs";
  try {
    const fileContent = import_fs.default.readFileSync(options.configFilePath, "utf8");
    const jsonObject = JSON.parse(fileContent);
    const apiPathObj = convertApiPathToObject(jsonObject);
    createApiFile(import_path.default.dirname(options.configFilePath), fileExt, apiPathObj, templatePath);
    if (options.log) {
      console.timeEnd("auto-create-api");
      console.log("auto-create-api : success!");
    }
  } catch (e) {
    if (options.log) {
      console.error(`auto-create-api : ${e}`);
    }
  }
};

// src/rollup.js
var import_path2 = __toESM(require("path"), 1);
var rollup_default = (options = {}) => {
  const defaultOptions = {
    folderPath: "apis",
    pathsFileName: "paths.json",
    ts: false,
    log: false
  };
  const mergedOptions = { ...defaultOptions, ...options };
  const configFilePath = import_path2.default.join(process.cwd(), "src", mergedOptions.folderPath, mergedOptions.pathsFileName);
  return {
    name: "create-apis",
    // 在构建开始前初始化插件
    buildStart() {
      const watcher = import_chokidar.default.watch(configFilePath || ".", {
        ignored: /node_modules/,
        // 忽略不需要监听的目录
        persistent: true,
        ignoreInitial: true
        // 忽略初始化时的文件变动事件
      });
      watcher.on("change", (filePath) => {
        create({ ...mergedOptions, configFilePath });
      });
      return () => watcher.close();
    }
  };
};
